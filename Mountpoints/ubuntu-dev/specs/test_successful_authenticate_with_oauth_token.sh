#!/bin/bash

# This script will call the consumer API (mobile API) and attempt to get an OAUTH token
# which it will then use to call the consumer API

# load variable names
. api_config_variables

# load provision keys for each API
# the below file was generated by the script 'load_oauth2_plugins_and_obtain_provision_keys.sh'
. provision_keys

# load client_credentials
# the below file was generated by the script 'provision_consumer_app.sh'
. client_credentials

# now call the public kong interface to request a token as if I am a client/sdk app
# NOTE client_* parameters would have been previously provided to this customer
# username/password would have been created by the end user in the sign-up use case.
# for this I am checking the credentials are correct in WireMock.
# See the wiremock mountpoint at wiremock:/mappings/user_authenticate_*.json
#
# Note, that while the authentication API is used to authenticate *all* secure APIs
# The call must pass the 'scope' of the secure API that the user desires access to.
# This will ensure that that a provision_key from the appropriate secure API can be
# obtained.
#
# The format of the scope parameter is: /<api-name/v<n.m>. e.g., /merchant/v1.0.

echo calling authentication API as an end user and passing:
echo
echo POST https://kong:8443/authenticate/$API_VERSION
echo client_id=$MOB_CLIENT_ID
echo client_secret=$MOB_CLIENT_SECRET
echo scope=${SECURE_API_REQUEST_PATHS[0]}/$API_VERSION #the consumer API base URL
echo username=$AUTH_USERNAME
echo password=$AUTH_PASSWORD

CLIENT_REQUEST=$( http --verify=no POST https://kong:8443/authenticate/$API_VERSION \
	client_id=$MOB_CLIENT_ID \
	client_secret=$MOB_CLIENT_SECRET \
	scope=${SECURE_API_REQUEST_PATHS[0]}/$API_VERSION \
	username=$AUTH_USERNAME \
	password=$AUTH_PASSWORD )


echo

if [ $(echo $CLIENT_REQUEST | grep -c "Successfully authenticated") -eq 1 ]; then
	#successful authentication
	echo STATUS:success
else
	#failed authentication
	echo STATUS:failure
	exit 1
fi

# Ordinarily the Authenication server would make a call to Kong *before* responding to the
# Client application. This is as documented here:
# https://getkong.org/plugins/oauth2-authentication/#resource-owner-password-credentials.
# However, wiremock can't do that, so the below call is made to show the call that the
# Authentication Service would make at that point. From the Kong docs:

	# The backend of your web-application will authenticate the username and password
	# sent by the client, and if successful will add the provision_key and
	# authenticated_userid parameters to the parameters originally sent by the client,
	# and it will make a POST request to Kong at your API address, on the
	# /oauth2/token endpoint. If an Authorization header has been sent by the client,
	# that must be added too.

# Note that body of this post is not JSON, but standard application/x-www-form-urlencoded
# data. It must be this way as the RFC requires and Kong only responses to the request
# in this format.

# Note also that the *specific* secure API's /oauth2/token endpoint must be
# invoked and the provision_key used must be the one associated with that
# specific API. The Authentication Service must use the 'scope' parameter to
# determine which specific secure API to call for the token. Note that the Kong
# ACL plugin will reject the request if the client_id is not permissioned to
# access that specific API (ie, it is not 'scope'd for that API)

echo Now calling the /oauth2/token endpoint of a specific API on Kong to get an oauth token
echo POST https://kong:8443${SECURE_API_REQUEST_PATHS[0]}/oauth2/token
echo grant_type=password
echo client_id=$MOB_CLIENT_ID
echo client_secret=$MOB_CLIENT_SECRET
echo provision_key=$consumer_KEY
echo authenticated_userid=$AUTH_USERNAME
echo
echo
echo Please refer to the code comments for more information.

ACCESS_TOKEN_RESPONSE=$( http --form --verify=no POST https://kong:8443${SECURE_API_REQUEST_PATHS[0]}/oauth2/token \
	grant_type=password \
	client_id=$MOB_CLIENT_ID \
	client_secret=$MOB_CLIENT_SECRET \
	provision_key=$consumer_KEY \
	authenticated_userid=$AUTH_USERNAME )

ACCESS_TOKEN=$(echo $ACCESS_TOKEN_RESPONSE | jq '.access_token' -r)
REFRESH_TOKEN=$(echo $ACCESS_TOKEN_RESPONSE | jq '.refresh_token' -r)
TOKEN_TYPE=$(echo $ACCESS_TOKEN_RESPONSE | jq '.token_type' -r)
EXPIRES_IN=$(echo $ACCESS_TOKEN_RESPONSE | jq '.expires_in' -r)

echo Got the following data from the request for a token
echo access_token: $ACCESS_TOKEN
echo refresh_token: $REFRESH_TOKEN
echo token_type: $TOKEN_TYPE
echo expires_in: $EXPIRES_IN
echo

# Now that we have a token, this response body should be sent back to the requester as a  response to the
# first HTTP Request in this script file.

# the below call makes the call again, from the perspective of the Client app (or SDK) on the assumption
# that this data was successfully sent back to the client.
echo Now calling the API with the token just received.
http --verify=no --print HBhb GET https://kong:8443${SECURE_API_REQUEST_PATHS[0]}/$API_VERSION/hello.json \
	Authorization:"Bearer $ACCESS_TOKEN" \
